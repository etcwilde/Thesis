% vim:set et sw=2 ts=4 tw=72:
\chapter{Discussion}\label{chap:discussion}

This chapter provides further discussion on the results and observations
from the study evaluating \tool{}. Included are observations that could
lead to improvements in the current DAG visualizations, the comments
from a release manager, and work toward applying the \mt{} model and
visualizations to other repositories.

\section{Interpreting the Results}\label{sec:interpreting_the_results}

Overall, the results indicate that \tool{} is able to improve the
correctness and accuracy of responses to various summarization tasks,
and decrease the time taken to produce the results. This doesn't come as
a surprise since the goal of the \mt{} model and the visualizations in
\tool{} are to provide better conceptual understanding and
summarizations of merges, while Gitk and DAG visualizations are designed
to show the topology of the entire repository. Since there are no other
tools for showing how a commit is integrated, and the topology of the
DAG does contain this information, the DAG visualization is used as a
proxy to show how a commit reaches the master branch.

One area of interest is the comparison of \tool{} and Gitk on
correctness in task T10, determining the modules modified in a merge.
Again, modules are no inherent to Git and are a property of the commits
in the Linux repository, the module is found in the summary of the
commit logs. In this task, there was not a statistically significant
difference in the number of correct responses between \tool{} and Gitk,
and, while significant, the effect on accuracy was also small. This is
interesting because \tool{} provided this information directly, while
users would have to look at the commit logs to determine this
information from Gitk. Further inspection of the merges show that this
was the only task where the correct answer was in the commit that was
provided, and actually required no aggregation of the results.

Another area of interest are the time results for task T7. This is the
only task where merge size had a significant impact on the performance
of the participants. There was not a statistically significant
difference in the time taken to respond to this task between the two
tools; however, the effect size indicates that the tool has a medium
effect on the time taken to respond. This is likely due to the sample
size. In the other tasks, the responses 11 responses for both merges
were combined, effectively doubling this number, creating 22 samples.
Since there was a difference in the time taken to respond given the
merge size, the results had to be analyzed separately. 11 samples is
quite small, and is likely not enough to have a 95\% confidence in the
results.

\section{Study Observations}\label{sec:study_observations}

Identifying the master branch was an issue that consistently came up
among all participants during the study. Some participants assumed that
the first line in the DAG visualization indicated the master branch,
while others assumed that the next branch tag indicated the master
branch. The DAG visualization provides no indication of which branch is
the master branch. Furthermore, the visualization in Gitk is not
consistent, branch colors and positions change between runs; identifying
the branch once does not guarantee that it is identifiable after
restarting Gitk.

Had the participants been able to easily identify the master branch, the
results from the study would likely be very different. This would be
most prominent in the summarization portion of the small merge, since
summarizing a single item is trivial, but the issue was identifying that
there was only a single item, which is currently not trivial. With more
than 25\% of the merges into Linux being single-commit merges, it is
important that users are able to identify them and understand the
changes being made within them. The structure of a single-commit tree is
identical to the structure of a flat tree, all commits are merged
directly into the master branch, passing through no other merges on the
way. Flat trees are the most common form of tree in the kernel
repository. To improve the visualization of the DAG for providing an
effective visualization for summarization and comprehension of flat
trees, it would likely be sufficient to indicate the master branch.
For the non-flat trees, a more powerful structure would likely be
necessary.

\section{Comments From a Release Manager}\label{sec:comments_from_a_release_manager}

One of the participants in the study had worked as a release manager for
more than three years, working with both SVN and CVS repositories. The
goal of a release manager is to determine how to merge the branches of a
repository in such a way that it minimizes merge conflicts and maintains
the meaning of the underlying source code. This section contains
insights from this participant, providing comments on ways that could
improve \tool{} and the \mt{} model.

Contributors making merges need to understand more than just what merges
a commit was collected into before reaching the repository of the
contributor. It is also important to understand order that the related
commits were made, as the order tells the story of what the developer
was thinking as they were writing the changes. The visualization of the
\mt{} in \tool{} does not order the commits, randomly ordering them in
each level as atomic units.

This is the primary reason behind why this participant would ask to use
both tools simultaneously. \tool{} is able to help with the aggregation
of the information, and provide a better understanding of the next merge
involved in integrating this commit, but the DAG visualization in Gitk
provides the full story of the commit instead of hiding it behind a
layer of abstraction.

The comments from this participant were very insightful, and will help
to improve the \mt{} model.

\section{Threats to Validity}\label{sec:threats_to_validity}

While precautions were taken to mitigate threats to the validity, for
pragmatic reasons and other errors, some threats must be taken into
account when considering the results. These threats, the mitigation
techniques, and the steps to minimize other threats are provided in this
section.

\subsection{Internal Validity}\label{sub:internal_validity}

In order to minimize the effects of order bias, the order that the tools
were used, the commits were analyzed, and the tasks were performed was
randomized for each participant. This leaves a lot of room for error in
the part of the person performing the study. To minimize this room for
error, a script was used to generate the exact text that needed to be
used during the study. While this method proved to be very useful, I
omitted one task during the course on one study. As a result, the
information collected from this participant were removed from the pool
during analysis.

The merges chosen from the repository may not be a good representation
of the merges in the repository. These merges were chosen to be from the
first and second quartile to help select merges that were of common
sizes. Of course, these are two merges out of thousands, and were
selected randomly from the set of all merges.

The answers provided by participants to earlier tasks were not taken
into account when evaluating the correctness or accuracies to following
tasks. The results of an incorrect answer may impact the results of the
tasks that followed. If the participant was unable to determine the
correct commits that were being merged, then none of the summarizations
would be correct, even if the response was correct given the commits
they identified. A future study could mitigate this by providing the
correct set of commits that are being merged between the conceptual and
summarization task sets to limit the propagation of errors.

\subsection{External validity}\label{sub:external_validity}

While many online git resources, Gitk, and the git command line provide
visualizations of the DAG, many participants were unfamiliar with the
DAG visualizations. Other tools than Gitk and the command line may
provide better summarizations and different visualizations, I am not
aware of any. I investigated the use of other GUI tools on the git
website, but none were able to produce visualizations for repositories
that are at the size of the Linux kernel repository, except for Gitk and
the git command line. While this may have had an effect on the results,
the tools listed on the website provide a very similar visual DAG
metaphor to the visualization in Gitk.

The participants in the study were students, some with industrial
experience. Most participants had worked with relatively few
collaborators on academic projects. Many of the participants had worked
with larger repositories while performing a research study. Even though
the participants have worked with large repositories during the course
of their research, professional developers are the target audience of
this tool, so working with professional developers would provide more
meaningful results.

\section{Limitations}\label{sec:limitations}

The model is designed with the Linux repository in mind. The viability
of \mt{s} to provide useful and accurate information relies on a few
properties of the underlying repository. The repository must use a
branch and merge structure. Some repositories, like the OCaml
repository, commit directly into the master branch. At release time, a
branch is created for the version being released. Patches to the version
are added as necessary. The release branch is never merged back into the
master branch. Since \mt{s} are designed to show how a commit is
integrated into the master branch, an \mt{} will not help with a
repository with this structure.

Repositories cannot have foxtrots. A foxtrot confounds the master
branch, making it impossible to properly determine where the integrating
merge occurs. The algorithm will continue to process repositories
containing foxtrots; however, the resulting \mt{s} will not be
meaningful.

Repositories should limit the use of fast-forward merging. The goal of
\mt{s} is to help understand how commits are grouped together, which is
done at a merge commit. Fast-forward merges splice the changes directly
into the underlying branch, hiding the fact that there was ever a
branch. The original branch information is not retrievable and will
result in many flat trees, where everything is merged directly into the
master branch, or worse, the master branch contains only individual
commits.

\section{Future Work}\label{sec:future_work}

The study presents two models. The first has undergone a study, and
while it helped users summarize aspects of a merge more quickly, there
was one major shortcoming. The proposed model does not maintain the
relationship between commits, only that they share a merge. This is
addressed by the proposal of second model, that maintains this
information while still removing unnecessary information from the
visualization. The algorithm has not been verified. The output of the
algorithm must be verified against the merges in the repository. A
similar evaluation to the one conducted against the results of the
original study would work, or simply comparing against the results of
the original algorithm should be sufficient. Once the trees are
generated and evaluated, the visualizations of the trees should be
evaluated to ensure that users are still able to determine how a commit
is merged, but also to ensure that users are able to understand the
relationships between the commits.

The work done in this \paper{} addresses a visible issue with
comprehending the visualization of the DAG\@. At no point is it verified
that the work is applicable to the problems faced by practitioners in
industry. While this is due to accessibility, future work should perform
a study to verify that the \mt{} model is able to help solve issues in
industry.
