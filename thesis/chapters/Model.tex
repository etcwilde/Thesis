% vim:set et sw=2 ts=4 tw=72:
\chapter{Model}\label{chap:Model}

Leveraging the topological information in Chapter~\ref{chap:background},
we design a model that groups commits by the integrating merge into the
master branch. Since the merges into the Linux kernel are atomic, all
the context necessary for merging a commit is available at the
integrating merge. The model is a tree-based model that we call the
\mt{}.

The \mt model abstracts the DAG of the repository into a set of \mt{s}.
Each \mt is rooted at a merge into the master branch. The leaves of this
tree are the commits and the merges are the inner nodes. A \mt is built
recursively with every merge in the \mt merging a sub-\mt. Any merges
that a commit must pass through to reach the master branch become an
inner node of the tree. Effectively, a \mt is a tree that shows the path
that commits follow in their way to the master branch of a repository.
The \mt{s} also help understand how commits were grouped together in
order to be integrated. In this model, not only has the DAG been
inverted (and simplified), but the entire notion of parent-child
relationship has been reversed. Due to this property, the terminology
will be different depending on the model we are referring to; when we
are referring to the \mt, the parent is the next node toward the merge
into the master branch, or the root of the tree. When referring to the
DAG, the parent relationship is in the opposite direction, from the root
toward the branch-point. In addition to identifying the path that a
commit took to being merged, we are able to aggregate the commit
metadata at merges as we retain the parent-child and child-parent
relationship for each event and know which commits belong to the merge.

To illustrate this model we will use a small example: assume the commits
represented in Figure~\ref{fig:repoEvents} show the sequence of events
in a repository. The sequence starts with the initial commit in the
master branch of the master repository at time $t_0$. Repository event 1
is a commit, which gets forked into a separate repository, \textit{Repo
  A}, where another commit is made, event 2. Event 5 is a merge event,
merging event 2, 3, and 4 into \textit{Repo A}. Event 5 is branched
from, commit 6 happens in the new branch, while commit 7 is added
simultaneously to the original branch in \textit{Repo A}. Events 11 and
12 are both merge events, merging changes made in \textit{Repo A} into
the master branch of the master repository. As every repository is a
first-class repository, including local copies and forks, git does not
distinguish between forked repositories and branches, and in neither
case does it explicitly record where a commit was made. In this case,
commits are performed in various repositories and branches. The DAG
representation of these events is shown in Figure~\ref{fig:repoDAG}.

\begin{figure}[htbp]
  \centering
  \resizebox{0.8\textwidth}{!}{
  \begin{tikzpicture}[auto, on grid, semithick, state/.style={circle, text=black}]
    \foreach \x in {0, 1, 2, 3, 4, 5, 6, 7}
    \draw[shift={(\x + 0.5, -0.5)}, color=black] (0cm, 4cm) -- (0pt, -0.2cm);

    \node[state, draw=chartblue] (1) {1};
    \node[state, draw=chartyellow, above right= of 1] (2) {2};
    \node[state, draw=chartmagenta, above right= 2cm and 1cm of 2] (3) {3};
    \node[state, draw=chartblue, right= 2cm of 1] (4) {4};
    \node[state, draw=chartyellow, above right=of 4] (5) {5};
    \node[state, draw=chartred, above right=of 5] (6) {6};
    \node[state, draw=chartyellow, right=of 5] (7) {7};
    \node[state, draw=chartmagenta, above right= 2cm and 1cm of 7](8) {8};
    \node[state, draw=chartyellow, right= 2cm of 7] (9) {9};
    \node[state, draw=chartyellow, right=of 9] (10) {10};
    \node[state, draw=chartblue, below right=of 9] (11) {11};
    \node[state, draw=chartblue, below right=of 10] (12) {12};

    \draw (12) edge (11) edge[chartyellow] (10);
    \draw (11) edge (4) edge[chartyellow] (9);
    \draw (10) edge[chartyellow] (9);
    \draw (9) edge[chartmagenta] (8) edge[chartred] (6)
              edge[chartyellow] (7);
    \draw (8) edge[chartmagenta] (7);
    \draw (7) edge[chartyellow] (5);
    \draw (6) edge[chartred] (5);
    \draw (5) edge[chartmagenta] (3) edge[chartyellow] (2)
              edge[chartyellow] (4);
    \draw (4) edge (1);
    \draw (3) edge[chartmagenta] (2);
    \draw (2) edge[chartyellow] (1);

    \node [draw=chartblue, below = 1.5cm of 1] (l1) [thick, minimum height=0.8cm]{Master};
    \node [draw=chartyellow, below = 1.5 cm of 4] (l2) [thick, minimum height=0.8cm]{Repo A};
    \node [draw=chartred, below = 4.5cm of 8] (l3) [thick, minimum height=0.8cm]{Branch of Repo A};
    \node [draw=chartmagenta, below = 1.5 of 12] (l4) [thick, minimum height=0.8cm]{Repo B};

        \foreach \x in {0, 1, 2, 3, 4, 5, 6, 7, 8}
    \node[shift={(\x, -0.6)}, color=black] {$t_\x$};
  \end{tikzpicture}
}
  \caption{An example sequence of events performed in different
    repositories. The horizontal axis represents time. The branches and
    repositories are aligned horizontally, and color-coded. Each commit
    points to its parent. The initial commit is at time $t_0$, and the
    head is at $t_8$.}
  \label{fig:repoEvents}
%\vspace{-3mm}
\end{figure}

The DAG does not retain information about where a commit was originally
created beyond the order of the events in the parent list. This is
necessary to provide complete flexibility to users, but at the expense
of maintaining a consistent history. Ideally, we would be able to
completely reconstruct the information in Figure~\ref{fig:repoEvents}
from Figure~\ref{fig:repoDAG}, but this may not be possible. Instead, we
focus on determining the next merge that leads to the integration of a
commit. Depicted in Figure~\ref{fig:repoTree}, is the first version of
the \mt. It does not completely rebuild the lost information, but is
able to show the sequence of merges that a commit follows to be
integrated, and the commits that were involved with the integration.

\begin{figure}[htbp]
  \centering
  \resizebox{0.8\textwidth}{!}{
  \begin{tikzpicture}[auto, on grid, semithick, state/.style={circle, text=black, black}]
    \node[state, black] (1) {1};
    \node[state, black, above right= of 1] (2) {2};
    \node[state, black, above right= 2cm and 1cm of 2] (3) {3};
    \node[state, black, right= 2cm of 1] (4) {4};
    \node[state, black, above right=of 4] (5) {5};
    \node[state, black, above right=of 5] (6) {6};
    \node[state, black, right=of 5] (7) {7};
    \node[state, black, above right= 2cm and 1cm of 7](8) {8};
    \node[state, black, right= 2cm of 7] (9) {9};
    \node[state, black, right=of 9] (10) {10};
    \node[state, black, below right=of 9] (11) {11};
    \node[state, black, draw=chartblue, below right=of 10] (12) {12};

    \draw (12) edge[-stealth] (11) edge[-stealth] (10);
    \draw (11) edge[-stealth] (4) edge[-stealth] (9);
    \draw (10) edge[-stealth] (9);
    \draw (9) edge[-stealth] (8) edge[-stealth] (6)
              edge[-stealth] (7);
    \draw (8) edge[-stealth] (7);
    \draw (7) edge[-stealth] (5);
    \draw (6) edge[-stealth] (5);
    \draw (5) edge[-stealth] (3) edge[-stealth] (2)
              edge[-stealth] (4);
    \draw (4) edge[-stealth] (1);
    \draw (3) edge[-stealth] (2);
    \draw (2) edge[-stealth] (1);
  \end{tikzpicture}
  }
  \caption{DAG representation of the commits represented in
    Figure~\ref{fig:repoEvents}. The DAG loses information about which
    repository the commit is performed in and through which merges it
    has passed on its way to the master branch. The DAG does not even
    distinguish the master branch from other branches.}
  \label{fig:repoDAG}
%\vspace{-3mm}
\end{figure}

\begin{figure}[htpb]
  \centering
  \resizebox{0.8\textwidth}{!}{
    \begin{tikzpicture}[auto, on grid, semithick, node distance=1cm, state/.style={circle, text=black, minimum size=7mm}]

      \node[state, draw=chartblue] (1) {1};
      \node[state, draw=chartblue, right=of 1] (4) {4};
      \node[state, draw=chartblue, right=of 4] (11) {11};
      \node[state, draw=chartblue, right=2.5cm of 11] (12) {12};

      \node[state, draw=chartyellow, above right= 1cm and 0.5cm of 11] (7) {7};
      \node[state, draw=chartyellow, above left= 1cm and 0.5cm of 11] (5) {5};
      \node[state, draw=chartyellow, right=of 7] (9) {9};
      \node[state, draw=chartyellow, left=of 5] (2) {2};
      \node[state, draw=chartmagenta, above=of 5] (3) {3};
      \node[state, draw=chartmagenta, above left=1cm and 0.5cm of 9] (6) {6};
      \node[state, draw=chartmagenta, above right=1cm and 0.5cm of 9] (8){8};
      \node[state, draw=chartyellow, above=of 12] (10) {10};

      \draw (11) edge[chartyellow, stealth-] (2) edge[chartyellow, stealth-] (5) edge[chartyellow, stealth-] (7) edge[chartyellow, stealth-] (9)
      (5) edge[chartmagenta, stealth-] (3)
      (9) edge[chartmagenta, stealth-] (6) edge[chartmagenta, stealth-] (8)
      (12) edge[chartyellow, stealth-] (10);
    \end{tikzpicture}
  }
  \caption{The \mt{s} computed for each commit in
    Figure~\ref{fig:repoDAG} showing the path that each commit takes to
    be merged into the master branch of the repository. This does not
    indicate how the events being merged are related. We retained the
    numerical order of the events, but the order can be arbitrary.}
  \label{fig:repoTree}
\end{figure}

Using the depth of the node from the root of the tree, we are able to
reconstruct the branch information. In our events, nodes 2, 5, 7, and 9,
are all on the same branch, and are merged into node 11. Nodes 5 and 9
are merge nodes, 5 merges a single commit into the branch, and 9 merges
two nodes into the branch. In some cases, it is possible that a commit
was merged twice. In the case of node 9, it is merged into 11, though it
could also be merged into 12 through 10. We design the merge tree to use
the shortest distance in hops, and use distance in time as a tie
breaker.
