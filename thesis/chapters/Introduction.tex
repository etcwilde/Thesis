% vim:set et sw=2 ts=4 tw=72:
\chapter{Introduction}

Understanding the process in which a piece of software is developed is
crucial in the process of determining why certain changes were made, how
the changes were made, and how the surrounding code was modified to
accept those changes. Git is a distributed version control software,
designed to facilitate collaborative software development between
thousands of people working independently around the world. Git uses the
Directed Acyclic Graph (DAG) model to store modifications to code in
individual commits. The model enables git to have impressive flexibility
compared to many other version control systems, but suffers from poor
visualizations stemming from the DAG. In large projects, the
visualization of the DAG, as shown in git, does not provide an adequate
summarization of how a commit is integrated into the master branch of a
repository.


While there has been extensive research on visualizing git repositories,
previous work does not focus on showing how a commit is integrated. The
literature on repository visualization and summarization can be broken
down into three main subcategories;
communication\cite{Cubranic2005,Begel2010}, aspect-oriented
visualization\cite{Ambros2005,Burch2005,Ambros2009}, and organic
visualizations\cite{ogawa09,Caudwell2010}. A fourth category can be
added to include non-academic tools, like GitKraken and SourceTree,
built as clients to work with git repositories and visualize the DAG
model directly.

In this \paper{} \evan{dissertation, thesis, or paper?}, we describe the
design of a model, the \mt{}, and the construction and evaluation of a
tool, \tool{}, designed to clearly visualize the path that commits take
to be integrated, and what other commits are related to it. \tool{} is
built around the \mt{} model using the Linux repository. Linux was
requested by an external entity with interest in maintenance of older
versions of the kernel for use in Android distributions. Linux makes
sense as a good platform for understanding the various uses of git, as
it was designed to replace Bitkeeper as the version control system for
the Linux repository in 2005, so the repository makes use of nearly
every feature of git. Our dataset includes commits from as far back as
2001 and as recent as 2014, though for this \paper{}, we will mostly
concern ourselves with the commits contributing to kernel versions 3.1
through 3.16, or the commits that were integrated into the kernel
between October, 2011 and August 2014.

When constructing and evaluating the model and tool, three questions
arose; first, we want to ensure that the visualizations of the directed
acyclic graph (DAG) do not already provide meaningful summarization of
how a commit is integrated (RQ\ref{rq:RQ1}). Next, we want to compare
the visualization of the DAG against the visualization of the \mt{} to
determine which is capable of providing a better understanding of how a
commit is integrated (RQ\ref{rq:RQ2}). Finally, the new model should
make it possible to more easily extract additional aggregate information
about what is being integrated, and who is making the contributions
(RQ\ref{rq:RQ3}).

%% TODO: Move to methodology section
\begin{textbox}
  \textbf{RQ\rqs{rq:RQ1}:} Do visualizations of the DAG provide
  users with a meaningful visualization of how commits are integrated?
\end{textbox}

\begin{textbox}
  \textbf{RQ\rqs{rq:RQ2}:} How does the visualization of the \mt{}
  compare with the visualization of the DAG to determine how commits are
  integrated?
\end{textbox}

\begin{textbox}
  \textbf{RQ\rqs{rq:RQ3}:} What other information can be drawn from the
  \mt{} model that cannot easily be drawn from the DAG.
\end{textbox}

%% TODO: More is described in the background section of the paper

\section{Related Work}\label{sec:related_work}

The \define{Version Control System}{VCS} tracks the development of a
software project, recording each change as it happens. In many cases,
the VCS contains the entire story of the software, with rich information
about the authors, files, and changes being made. This makes the VCS
vital in providing information about how a software project is being
developed, how the software is structured, and extending Conway's law,
can reflects the communication structure within an organization. In
order to use the information stored in the VCS, users must be able to
gain a clean understanding and summarization of the changes being made
and how they interact with the rest of the source code. Various
visualizations of have been written to tackle various aspects of this
challenge, but we are aware of no git repository visualization tool that
was designed with the explicit goal of showing how commits are
integrated into the master branch of the repository. There has, however,
been a lot of work in providing visualizations of various aspects of a
repository.

Many tools focus on addressing the issue in communication between
developers in inter-team collaborative work. Hipikat\cite{Cubranic2005}
investigates communication between developers, focusing on assisting
with the integration of new developers into a project though
communication, providing the new developer with searchable artifacts of
the changes being made, and where to find them. Codebook\cite{Begel2010}
also focuses on communication, but where Hipikat focuses on assisting
new developers find artifacts, Codebook assists developers with finding
who was responsible for creating the artifact. Codebook uses a
data-mining technique to determine the developer of a piece of code, the
program manager who wrote the specification for the code, and the
program managers and developers on the team who were working together.
Neither tool is designed with the goal of providing information on the
topological structure of a source code repository, nor are these tools
designed for visualization purposes.

Most visualization systems provide information about a certain aspect of
the contents in the repository. Fractal Figures\cite{Ambros2005} uses a
square to represent a component of a project. Then subdividing the
square based on the proportion of an author's contributions to that
component. EPOSee\cite{Burch2005} and Evolution Radar\cite{Ambros2009}
perform further analysis to determine which files are created together,
and see what changes are made over a sequence of commits. The goals of
these two projects differ slightly, but both use evolution over time to
extract information about how different parts of a software system are
related.

Codebook, Hipikat, Fractal Figures, EPOSee, and Evolution Radar all
extract data from CVS repositories. Our goal is to provide information
about git repositories. Fewer tools are available for generating
visualizations and summaries of git repositories, potentially due to the
DAG model used as the internal structure of git repositories.

Gource\cite{Caudwell2010} is a tool for providing an interactive
timelapse of the changes being made to various files stored in the
repository. Gource uses a graph metaphor for representing the file
structure in the repository. Files are the nodes in the graph, and the
clustering of the file represents directories. The edges are the links
between directories. User avatars move around the graph emitting
different color light depending on the change being made to the file.
Green indicates the creation of a new file, yellow indicates a
modification, and red indicates the deletion of the file (shown in
Figure~\ref{fig:gource_view}). Codeswarm\cite{ogawa09} is similar to
Gource, using an organic timelapse approach to visualizing the events in
the repository. Unlike Gource, which focuses on files, Codeswarm focuses
on developers and the number of commits each developer is making.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{./Figures/introduction/gource-linux.jpg}
  \caption{View of Gource file graph with users operating on a
    repository}
  \label{fig:gource_view}
\end{figure}
