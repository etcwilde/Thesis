% vim:set et sw=2 ts=4 tw=72:
\chapter{Introduction}

Version control records the changes being made to the files of a
project, enabling users to view previous versions of the files, view the
individual changes made, and restore the files back to a previous state
if necessary. The version control system also maintains a log of who
made changes and when those changes were made. By storing this
information, the version control system stores the history of the
project. Presented in the right way, there are many opportunities to use
this information to help users understand the architecture of the
software system, who is making changes, and which files are being
changed the most. While version control can be used in any context where
file history is desirable, version control is usually used in the
software development process.

Git is the \define{version control system}{VCS} designed for and used by
the Linux kernel project. In order to handle the number of people
contributing to the kernel from different countries, git was designed to
be distributed. Unlike in centralized repositories, where users must
re-synchronize with the server, a distributed version control system
provides each user with a full first-class repository. This allows the
user to have additional flexibility, and means that a user has to
synchronize less often. Furthermore, each user has a copy of the entire
repository, which means that they have access to all of the branches and
commits in the repository. This gives users the ability to change the
structure of the repository and make changes that would not work in a
centralized repository. To make it more useful to the Linux project, git
was designed to allow easy branching. Branches allow users to work on a
logically separate part of the repository, then the changes into the
repository once the feature is finished or the bug is fixed. This lets
users work for longer without needing to synchronize with the rest of
the project as often. To support these requirements, git uses a directed
acyclic graph to represent the repository. The nodes of the graph
represent the commits, containing the actual changes being made, along
with metadata about who is making the changes, when the changes were
made, and the parent nodes of the commit.

Visualizations of the graph are used to answer questions about the
development of the software including what changes are being made into
various branches, how the changes to the code are grouped, and who is
working with whom, among others. Maintainers use the visualizations to
understand what changes are being made to the current version of the
software in order to apply the necessary fixes to older versions of the
software to keep them secure and performing correctly. This requires
understanding how a commit is integrated into the repository, and other
commits that are merged with that commit. In large, active, software
repositories this task is not trivial. The graph can be large and
complicated, making the visualizations difficult to understand.

This \paper{} makes four contributions. First, a new tree-based model,
called the \mt{}, constructed from the underlying graph of the
repository. Compared to the graph, trees are relatively easy to
visualize, and there are many visualization metaphors that take
advantage of different properties of the trees. There are visualizations
designed for both short wide trees, as in the case of file systems, and
tall narrow trees. Furthermore, trees have fewer edges and relatively
strict properties, meaning that the visualizations are simpler. Second,
visualizations that take advantage of the \mt{} model. Third, an
implementation of the visualizations in a tool, called \tool{}. Finally,
an evaluation of the tool to determine whether visualizing the
repository using the model is useful. This \paper{} specifically studies
the Linux repository. The Linux repository is large and complex, with
more than 1000 contributors making changes every release. Details about
the repository are provides in Section~\ref{sec:linux}.

The central thesis of the paper is finding a means of visualizing a
repository that is as large and complex as the Linux repository in a
meaningful way that gives insight into how commits are integrated.

\begin{textbox}
  \textbf{Thesis:} How do we effectively visualize the graph of the
  Linux repository in a way that gives insight into how commits are
  integrated?
\end{textbox}

\section{Thesis Organization}\label{sec:thesis_organization}

This \paper{} is organized as follows. Chapter~\ref{chap:background}
contains background information about the motivation, the Linux
repository, and the structure of git.

Chapter~\ref{chap:model} introduces the \mt{} model. This chapter
includes a description of the model, an algorithm to convert from the
DAG to the \mt{}, and an evaluation of the resulting trees.

Chapter~\ref{chap:design_and_implementation} introduces \tool{},
providing the use-cases that were being targeted. This chapter also
includes the features that were implemented into \tool{}, including the
search engine, the summarization tables, and the tree visualizations.
More details on how the tool was implemented are included in
Chapter~\ref{chap:implementation_details}.

Chapter~\ref{chap:evaluation} is the empirical evaluation of \tool{},
and include the methodology and results of this two-part study. The
first part evaluates user comprehension of the DAG and the second part
compares visualizations and summarizations of the DAG in Gitk against
the visualizations and summarizations of the \mt{} in \tool{}.

Chapter~\ref{chap:discussion} discusses the results of the study
providing more insight on the results. The chapter includes observations
from the study, and the comments from one of the members of the study
who had worked as a release manager, and a description and algorithm for
an updated \mt{} that takes into account the comments and observations
from the study. The chapter concludes with the limitations of the work
and the future work.

Chapter~\ref{chap:conclusion} concludes that paper, reiterating the
problem and how it was solved.
