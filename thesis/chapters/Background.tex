% vim:set et sw=2 ts=4 tw=72:
\chapter{Background and Related Work}\label{chap:background}

A version control system tracks information, and how that information
changes over time. While it can be used for storing any digital
information, version control is usually used in the context of software
development; it is used for storing and managing the information about
the project, the source code, and the binary assets. Version control has
two primary purposes, first as a means of storing information, and
second as a means of retrieving historical versions of that information.
In addition to fulfilling the two primary purposes, modern version
control maintains a log of who is making the changes and when the
changes were made.

Early version control systems were designed for local development and
provided no means of collaboration. As software projects grew, the model
quickly became outdated, being replaced with a centralized server model.
Concurrent Version System (CVS) and Apache Subversion (SVN) are two
examples of centralized version control systems. The centralized version
control system provides means of collaboration through a client-server
interface. The repository is stored in a central server. Developers use
a client to check out parts of the repository, choosing parts that
pertain to the part they are editing.

In large open source projects, the centralized architecture becomes a
burden. Common tasks such as committing and changing branches requires
re-synchronization with the central server. In order to work, the
developer must always have access to the central server. To maintain the
atomic properties of committing, the server will momentarily lock to
ensure that no changes happen while a commit is being processed or a
conflict resolved.

Due to the limitations of a centralized architecture, the Linux kernel
uses a distributed version control system. Until April of 2005, the
kernel project used BitKeeper. In April 2005, the licensing became too
restrictive and the project needed to change the version control system.
Git was written as a replacement to BitKeeper. Git needed to be
implemented quickly so that Linus could return to the kernel, but was
also required to have the capacity to maintain a similar level of patch
granularity as BitKeeper\footnote{initial announcement of git on the
  mailing list
  \url{https://marc.info/?l=linux-kernel&m=111280216717070}}. The first
version of git was roughly 1300 lines of code and was written and
self-hosting in less than two\footnote{From the git mailing list
  \url{https://marc.info/?l=git&m=117254154130732}}.

Git is an implementation of a distributed version control system (DVCS).
Distributed Version Control gives developers more flexibility with their
local repository and requires synchronization less often than the
centralized version control systems. When a developer clones a
repository using git, the clone is a full stand-alone repository. A
developer is able to work independently on a feature committing and
branching within their local repository. Once the feature is complete,
the developer can push their changes to the upstream repository. Because
the local repository is completely separate, the developer has more
flexibility to alter the structure of their repository before pushing
the results back into the master repository. The developer can flatten
or add merges, and re-order, squash, edit, and split commits. These
features make it possible to commit more often without worrying about
commits being complete because the changes can be cleaned up before
being released.

With the additional flexibility, the structure of large and active
repositories is more complex than the repositories that are in
centralized version control. This poses a problem for maintainer who
must understand how a commit is integrated and the other commits that
are integrated with that commit. Maintainers must sift through thousands
of commits to determine which changes being made to the current version
of the software pertain to the area of the software that they are
maintaining. Specifically, maintainers must be able to answer two
questions;

\begin{textbox}
\begin{itemize}
  \item How is a commit integrated?
  \item What other commits are integrated with the commit?
\end{itemize}
\end{textbox}

The remainder of this chapters includes related work, a description of
git, the directed acyclic graph used internally by git, and information
about the Linux kernel repository.

\section{Related Work}\label{sec:related_work}

A Version Control System (VCS) tracks the development of a software project,
recording each change as it happens. By tracking the changes, the VCS
contains an entire story of the software, rich with information about
who the authors are, what files are being modified, what where changes
are being made. This makes the VCS vital in providing information about
how a software project is being developed and how the software is
structured. In order to use the information stored in the VCS, users
must be able to gain a clear understanding and summarization of the
changes being made, and how they interact with the rest of the source
code. While there has been extensive research on visualizing software
repositories, previous work does not focus on how commits and merges are
structures in the repository graph, and in extension, how commits are
integrated into a repository. The literature on repository visualization
and summarization can be broken down into three academic subcategories;
communication\cite{Cubranic2005,Begel2010}, aspect-oriented
visualization\cite{Ambros2005,Burch2005,Ambros2009}, and organic
visualizations\cite{ogawa09,Caudwell2010}. A fourth industrial category
exists, including tools like GitKraken and SourceTree. The goal of the
industrial tools is not to extract or synthesize new information from
the repository, but to act as a user-friendly client on top of what git
already provides.

\evantodo{Add links to GitKraken and SourceTree}

Many tools focus on addressing the issue of communication between
developers in inter-team collaborative work. Hipikat\cite{Cubranic2005}
investigated communication between developers, focusing on assisting
with the integration of new developers into a project though
communication, providing the new developer with searchable artifacts of
the changes being made, and where to find them. The artifacts may
include files or bug information, shown in Figure~\ref{fig:hipikat}.
Codebook\cite{Begel2010} also focused on communication, but where
Hipikat focused on assisting new developers find artifacts, Codebook
assists developers with finding who was responsible for creating the
artifact. Codebook used a data-mining technique to determine the
developer of a piece of code, the program manager who wrote the
specification for the code, and the program managers and developers on
the team who were working together. A screenshot of Hoozizat, an
implementation of codebook, is shown in Figure~\ref{fig:codebook}.
Hoozizat and Hipikat use the version control as the archive of artifacts
that are being queried. Neither tool is designed with the goal of
providing information on the topological structure of a source code
repository, nor are these tools designed for visualization purposes, but
they do draw information from the contents of the version control
system.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.9\linewidth]{Figures/introduction/hipikat_bug.png}
  \includegraphics[width=0.9\linewidth]{Figures/introduction/hipikat.png}
  \caption{View of Hipikat, listing bugs that are similar to the one
  being viewed}
  \label{fig:hipikat}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/codebook.png}
  \caption{A screenshot of the search results on Hoozizat, an
    implementation of codebook.}
  \label{fig:codebook}
\end{figure}

Most visualization systems provide information about a certain aspect of
the contents in the repository. The goal being Fractal
Figures\cite{Ambros2005} is to show the division of work between
contributors. The project is represented as a square. The square is then
subdivided based on the proportion that a given contributor contributed
to the project, shown in Figure~\ref{fig:fractal_figures}. The
visualization makes it easy to see where work is evenly divided versus
the projects where a single contributor is doing most of the work.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/fractal_figures.png}
  \caption{Construction of Fractal Figures}
  \label{fig:fractal_figures}
\end{figure}

EPOSee\cite{Burch2005} and Evolution Radar\cite{Ambros2009} use the
information from the version control to determine which files are edited
together. The tools from these papers are designed to help a user
identify the degree to which two files are coupled. Two files are
edited and committed together frequently are said to be more tightly
coupled. This makes it possible to determine when two classes are
semantically related. The evolution radar shown in
Figure~\ref{fig:evolution_radar} places points on a circle based on the
name and coupled they are. The files are arranged around the circle
based on the file name, including the full file path. This has the
effect of grouping files that are from the same directory. The distance
from the center of the circle is dependent on how tightly coupled the
file is to the file be analyzed. A more tightly-coupled file will be
positioned more closely to the center of the circle.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/evo_radar.png}
  \caption{Evolution Radar visualization}
  \label{fig:evolution_radar}
\end{figure}

Hoozizat, Hipikat, Fractal Figures, EPOSee, and Evolution Radar all
extract data from CVS repositories. Our goal is to provide information
about git repositories. Fewer tools are available for generating
visualizations and summaries of git repositories, potentially due to the
DAG model used as the internal structure of git repositories.

\evantodo{Look at this one}
Organic visualizations show patterns in cooperation and communication
that arise within a software project organically. Heller et
al.\cite{Heller2011} plots communication on a map. This visualization
shows communication and cooperation patterns that arise, and how they
cross country boundaries, within a software project. The visualizations
proposed in Gource\cite{Caudwell2010}, shown in
Figure~\ref{fig:gource_view}, shows which files contributors are working
on. Using this, it is possible to draw conclusion about which parts of a
project a given contributor is working on and the group of contributors
working on a given area. Gource uses a graph metaphor structure to
represent the file structure of a repository. Files in the same
directory cluster together to form a node. Edges between the directory
clusters represent which directory contains another, although there is
no way to determine the direction of the relationship. User avatars move
around the graph emitting different beams of colored light depending on
the change being made to the file. Greed indicates the creation of a new
file, yellow indicates a modification, and red indicates the deletion of
a file. The visualization is animated to show how a project grows over
time. Codeswarm\cite{ogawa09}, shown in Figure~\ref{fig:codeswarm}, is
similar to Gource, using an organic timelapse approach to visualizing
the events in the repository. Unlike Gource, which constructs a graph
from the directory structure of project, Codeswarm does not have a graph
structure; developers are the center of the visualizations. When a
developer makes a change to a file, the file lights up and flies toward
the developer. As a developer makes more changes, the files that the
developer is modifying will form a ring around the developer. If
multiple developers are modifying a file, the developer nodes are drawn
together.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{./Figures/introduction/gource-linux.jpg}
  \caption{View of Gource file graph with users operating on a
    repository}
  \label{fig:gource_view}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/codeswarm.png}
  \caption{View of the Postgresql repository in Codeswarm}
  \label{fig:codeswarm}
\end{figure}

There are many non-academic tools that are designed as an interface to
git. While not all of these programs provide visualizations, those that
do use a visual metaphor of the DAG to show topological information
about the commits in the repository. While they ultimately show the same
information, the topology of the repository, the organization of that
information is different.

GitKraken, shown in Figure~\ref{fig:gitkraken_main},  is a popular
commercially written git interface that aims to be efficient, elegant,
and reliable, according to it's official website. On visual inspection,
it appears to satisfy these goals. Overall, the interface is clean, most
actions that are possible with the git command line are available in the
graphical interface. Overall, the tool is effective and garners online
approval from users. The graph itself, shown in the center of the main
view provides users with the same information as the graph visualization
in gitk and the git command line, though it may be visually more
appealing.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/gitkraken_main.png}
  \caption{Screenshot of the main view in GitKraken}
  \label{fig:gitkraken_main}
\end{figure}

GitLab and GitHub are both online repository hosts, with
visualization and summarization provided as well. While the GitLab
visualization does not appear to provide any additional information, the
visualization provided by GitHub takes advantage of additional internal
knowledge to display information about forks. Through this
visualization, GitHub displays the branch history of the repository
network, including the branches of the main repository and forks from
that. Giteye and most of the other visualizations are relatively
conventional, simply cleaning up the interface of Gitk, the visualizer
that is shipped with git. With the exception of Gitk, no GUI visualizers
are able to produce a visualization for the Linux repository, due to its
size: the GitHub visualizer displays an error message, stating that
there are too may forks to display; the GitKraken interface will freeze
and eventually crash while trying to load the repository, while Giteye
and the other visualizers will consume all of the system memory before
they are able to produce a visualization. The Gitk interface is the
least polished, but is able to produce a visualization of the
repository.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/giteye_graph.jpg}
  \caption{Screenshot of Giteye DAG view of a repository}
  \label{fig:giteye_screenshot}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/github_dag.png}
  \caption{GitHub online network view of a repository}
  \label{fig:github_dag_screenshot}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/gitlab_graph.jpg}
  \caption{GitLab online graph view}
  \label{fig:gitlab_dag_screenshot}
\end{figure}

\section{Git}
\label{sec:git}

% Objects;
At the deepest level, git is a key-value store with additional
components on top. Objects are the most basic internal-unit in
git\footnote{More information about git objects is available at
  \url{https://git-scm.com/book/en/v2/Git-Internals-Git-Objects}}. Git
stores all of the actual data stored in a repository as objects. There
are three types of objects; blob objects, tree objects, and commit
objects. Blob objects contain the contents of the files in the
repository. Tree objects are the equivalent of Unix directories. The
tree objects contain one or more sha-1 references to blob or tree
objects that are contained within that tree. Commit objects are used to
store the commit metadata. Git objects are exposed through the plumbing,
but are not designed to be used directly. While git is technically a
key-value store with an internet connection, it is best to use it as a
version control system.

% Commits;
Commits are the most basic unit of change in the git repository that is
exposed through the normal git interface. Commits are how the changes
and metadata are stored. Commits in git are immutable; they cannot be
changed once they are created. Instead, modifying a commit will result
in a new commit with a different commit hash. Because the commits that
follow have references to the updated commit, those commits are copied
and receive a new commit hash as well. Commits store the associated
commit object, commit hash, commit date, committer, author, and
authorship date, the patch, and an ordered list of parents. The parents
of a commit are the next commits toward the initial commit. The first
parent in the list is the commit that is on the same branch as the
commit that is being created, i.e, the branch that the other branches
are being merged into. The remaining commits are the branches being
merged, in the order that they are specified in the merge. A non-merging
commit will only have one parent. To clarify the difference, non-merging
commits are referred to as commits, merging commits as merges, and both
indiscriminately as repository events or just events for the rest of
this \paper{}. The patch are set of changes being made to the files of
the repository.

% Integration;
Integration is the process by which the changes in a commit are added to
the main repository. Small changes have fewer dependencies in other
code, sometimes no dependencies. It is possible to merge these changes
into the main repository without additional commits making changes
elsewhere to accommodate this the small fix. These commits are usually
in the form of a bugfix, where only a single line is modified. Adding
larger features to a project usually requires additional support from
the rest of the project. The changes are not directly part of the
feature, but are required for the feature to be added to the software.
Sometimes the interface with a function needs to be updated; this type
of change causes breakage Wherever the function is called. The changes
that are made to the rest of the project to accommodate the interface
change are part of the integration of the change. Sometimes, it is
possible to implement a more efficient or secure version of a function
where the data meets certain requirements. There are changes that need
to be made in the rest of the project to take advantage of the faster
version of the function. The code involved with taking advantage of the
new function is part of the integration of those changes. The commits
that update the rest of the source to accommodate the new feature,
updated function, or new functions, are the commits that are involved
with integrating a commit. In order to integrate the changes, the
commits must be merged into the master branch of the repository. Commits
may be merged directly into the master branch, or may be merged into
multiple branches before finally reaching the master branch. To
understand how a commit is integrated, it is necessary to know which
merges a commit passes through to reach the master branch, and which
commits are merged with it.

Commits may pass through multiple merges on the path to the master
branch. The merges generally form logical separations, grouping related
code. Merges are a type of commit; it is possible to make additional
changes while merging. When two commits from different branches make
changes to the same file, a conflict occurs. Git is unable to determine
which changes are correct, so it flags them as a merge conflict, which
stops the merging process. The person making the merge decides which
change should be kept, and which should be removed. The resolution of
merge conflicts is stored as the patch of merge conflicts. The Linux
repository has no merge conflicts. This is attained through a different
workflow. When a developer wants to merge their changes, they must first
rebase their branch onto the most up-to-date commit of the repository.
Rebasing is the process of moving a branch to another commit in the
repository. When this happens, if there are conflicts, git will require
the developer to make the fixes. The main difference being that the
developer fixes conflicts, not the person performing the merge. The idea
behind this is that the developer likely has a better understanding of
which change is the correct, or how to integrate both changes.

\section{Directed Acyclic Graph}
\label{sec:directed_acyclic_graph}

To allow for the flexibility needed for a distributed control system,
git uses a \define{directed acyclic graph}{DAG} as the central
repository model. The repository events make up the nodes in the graph,
and the child-parent relationship represents the edges. Commits will
have a single parent, which is the repository event that is at the head
of the current branch. Merge nodes have an ordered list of
parents\footnote{It is possible for a merge to have many parents, commit
  2cde51fbd0f310c8a2c5f977e665c0ac3945b46d has 66 parents}, each parent
is the head of each branch being merged. The first parent is the head of
the current branch, and the other parents are the heads for the other
branches being merged, in the order that they are specified in the merge
command. Every repository will have at least one initial commit, which
will have no parents, but it is possible for repositories to have
multiple initial commits. Furthermore, it is possible for the graph of a
repository to be disconnected; these branches are known as orphan
branches.

The model itself is quite simple but flexible. While the flexibility of
a git repository is usually a strength, there are situations where it
makes reasoning about the contents more difficult. The idea of a main
master branch is useful for people who are working with the repository.
Unlike many centralized repositories, which have a concept of a main
branch, usually referred to as the trunk, git has no functional
requirement for the existence of a main branch. Instead, the main branch
is maintained by the discipline of the people committing code to the
repository. As a convention in git, the first parent of a node is on the
same branch as that node. A \foxtrot\footnote{See
  \url{http://bit-booster.blogspot.ca/2016/02/no-foxtrots-allowed.html}
  for a full description of the issue.} merge occurs when the parent
list is re-ordered, thus confounding the branch relationships
(depicted in Figure~\ref{fig:foxtrot_steps}).

\begin{figure}[htpb]
  \centering
  \begin{tabular}{ccc}
    \includegraphics[width=114px]{Figures/background/foxtrot_initial.png} &
    \includegraphics[width=145px]{Figures/background/foxtrot_good.png} &
    \includegraphics[width=145px]{Figures/background/foxtrot_bad.png} \\
    Initial Repository & No Foxtrot & Foxtrot
  \end{tabular}
  \caption{Depiction of a foxtrot merge, where the master branch is
    confounded by \emph{branch2}}
  \label{fig:foxtrot_steps}
\end{figure}

The nodes in the DAG are immutable; once a commit or merge is created,
it cannot be changed. Git allows operations to alter the events and
re-order them, but this will create a new event with a new commit hash.
This property makes it impossible for nodes to store information about
the children, and in extension, how the commit is being merged as this
information is not available when the commit is created. Git provides
the command \verb|git log --children|, which traverses the DAG and
inverts the edges. Combining this with the graph output partially solves
the problem of understanding how a commit is merged into the master
branch as it shows how a commit was merged; however, the resulting graph
is still complicated.

Most repositories are simple enough that it is possible to identify how
commits are integrated using the visualizations of the DAG that are
available with the current tools. Difficulties arise in larger
repositories. The master branch can be counfounded with \foxtrot{}
merges, making it difficult to identify. Sheer number of commits being
added to various branches at a given time can make it difficult to
understand which branch a commit is being added to.

\section{Linux}\label{sec:linux}

This \paper{} studies the repository of the Linux kernel. The repository
itself is complex, contain tens of thousands of commits per year and
thousands of merges. Older versions of the kernel are used in a wide
variety of situations including various Linux desktop distributions,
internet of things device firmware, web servers,
spacecrafts\footnote{Linux is used heavily at SpaceX
  \url{https://lwn.net/Articles/540368/}}, and in mobile devices as the
base of the Android platform. These kernels are sometimes modified forks
of the official Linux kernel, made to be more suitable for the specific
needs of the application. Due to these application-specific
modifications, it is not feasible to update to the latest version of the
kernel. While it may not be feasible to update, the changes being made
to the official version are necessary as they fix bus, patch security
issues, and improve performance. Due to the sometimes critical nature of
the patches being merged into the current version of the kernel, it is
necessary for maintainers working on an application-specific fork of the
kernel to sift through the commits coming into the official version,
looking for changes that may impact the kernel that they are
maintaining. This section presents some statistics about the contents of
the kernel repository.

Linux is open source, using git to track and manage the source code in
the kernel. A mirror of the repository is available on
GitHub\footnote{\url{https://github.com/torvalds/linux}}, which makes
data collection relatively straightforward. Described in this section is
the dataset that was collected, further investigating the number of
authors, commits, and merges.

The data extracted from the repository involves all merges into the
master branch between April 18, 2005 and August 14, 2014. This
corresponds to the merges added to the kernel between versions 2.6.11
and Linux 3.16. The commits collected from the repository include
commits authored between September 17, 2001 and December 6, 2014. There
are 4 commits in the dataset that are beyond this range due to the date
being incorrectly set on that developer's machine. There is one
incorrect date that is dated January 1, 1970, authored by Ursula Braun,
and three commits dated after 2014. These commits are dated April 5,
2019, October 14 2030, and April 25 2037, authored by Len Brown, Yanmin
Zhang, and Daniel Vetter, respectively. Commits are not necessarily
merged immediately, all commits were added between April 15, 2005 and
October 14, 2014. The average difference between when a commit was
created and when it was committed is 16 days and 10 hours; 25\% of the
commits were committed within 2 hours of being authored, 50\% committed
within 2 days and 8 hours, 75\% within 15 days, and all commits were
merged within 9.5 years of being authored. This breakdown of the kernel
data focuses on the commits integrated into kernel versions Linux 3.1 to
Linux 3.16, translating to the merges between July 21, 2011 and August
3, 2014.

As expected, the Linux kernel is highly collaborative and is very
active. Between 1000 and 1500 authors have contributions accepted into
the official kernel per release (shown in
Figure~\ref{fig:linux_authors_per_release}). These authors contribute
between 8000 and 14000 commits per release
(Figure~\ref{fig:linux_commits_per_release}). Between 275 and 400 merges
integrate the commits into the master branch of the kernel per release
(Figure~\ref{fig:linux_commits_per_release}). The Linux kernel
repository is a prime example of a successful open source project,
exemplifying the collaborative nature of modern software development.
The sheer number of commits being contributed make the task of filtering
the important or relevant commits impractical.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/background/linux_authors_per_release.pdf}
  \caption{Unique authors with contributions to each kernel version}
  \label{fig:linux_authors_per_release}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth, page=1]{Figures/background/linux_commits_per_release.pdf}
  \caption{Commits per release from Linux 3.1 to Linux 3.16}
  \label{fig:linux_commits_per_release}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth, page=2]{Figures/background/linux_commits_per_release.pdf}
  \caption{Merges per release from Linux 3.1 to Linux 3.16}
  \label{fig:linux_merges_per_release}
\end{figure}

While the number of integrating merges into the master branch appears to
be decreasing slightly per release, the number of commits per release is
increasing. The average (mean) number of commits per merge per release
has increased from slightly over 20 commits per merge in Linux 3.1 up to
50 commits per merge in Linux 3.16
(Figure~\ref{fig:linux_commits_per_merge_per_release}).

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth, page=3]{Figures/background/linux_commits_per_release.pdf}
  \caption{Commits per merge into each release of Linux from 3.1 to 3.16
    \evan{Should probably go in the appendix}}
  \label{fig:linux_commits_per_merge_per_release}
\end{figure}

Grouping commits by the merge that integrates it into the master branch
shows a different view of the kernel. The individual merges contain
relatively few commits, 25\% of the merges merge only a single commit,
and 50\% of the merges merge at most 7 events
(Figure~\ref{fig:linux_merge_distribution_per_release}).

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/background/linux_merge_distribution_per_release.pdf}
  \caption{Distribution of Merge Sizes per Release Between Linux 3.1 and
  3.16}
  \label{fig:linux_merge_distribution_per_release}
\end{figure}

Initially, the repository looks very large and unmanageable. Grouping
the commits using the merge into the master branch looks like a
promising means of simplifying the content. Most of the merges are only
merging 7 events, which is nearly trivial to visualize.
