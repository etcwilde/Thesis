% vim:set et sw=2 ts=4 tw=72:
\chapter{Background and Related Work}\label{chap:background}

A version control system tracks files, and how that information changes over time.
While it can be used for storing any digital information,
version control is usually used in the context of software development;
it is used for storing and managing the information about
the project, the source code, and the binary assets.
Version control has two primary purposes,
first as a means of storing information,
and second as a means of retrieving historical versions of that information.
In addition to fulfilling the two primary purposes, modern version
control maintains a log of who is making the changes and when the
changes were made.

Early version control systems, such as revision control system (RCS),
were designed for local development and provided no means of collaboration.
As software projects grew, the model quickly became outdated,
being replaced with a centralized server model.
Concurrent Version System (CVS) and Apache Subversion (SVN) are two
examples of centralized version control systems. The centralized version
control system provides means of collaboration through a client-server
interface. The repository is stored in a central server. Developers use
a client to check out parts of the repository, choosing parts that
pertain to the part they are editing.

In large open source projects, the centralized architecture becomes a
burden. Common tasks such as committing and changing branches requires
re-synchronization with the central server.
To work with the repository,
the developer must always have access to the central server.
To maintain the atomic properties of committing, the server will
momentarily lock the repository to ensure that no changes happen while a
commit is being processed or a conflict resolved.

Due to the limitations of a centralized architecture, the Linux kernel
uses a distributed version control system. Until April of 2005, the
kernel project used BitKeeper.
In April 2005, the licensing became too restrictive and Linux was forced
to change version control systems.
Git was written as the replacement for BitKeeper, and was designed to
maintain a similar level of patch granularity as in BitKeeper\footnote{
  initial announcement of git on the mailing list
  \url{https://marc.info/?l=linux-kernel&m=111280216717070}}. The first
version of git was roughly 1300 lines of code and was written and
self-hosting in less than two weeks\footnote{From the git mailing list
  \url{https://marc.info/?l=git&m=117254154130732}}.

BitKeeper is a distributed version control system (DVCS).
In distributed version control, the entire repository is mirrored on
the developer's local computer instead of copying parts of the project.
As a result, the local copy is much larger on disk than with a
centralized repository, but the developer has the freedom to make
changes to the code and to the
structure of the repository without needing to re-synchronize with a
central server.

When the developer makes a copy of a non-local repository, this is
called cloning.
The non-local repository is known as the origin repository.
When changes are made to the origin repository, the local clone must
resynchronize with origin in order to for those changes to be reflected.
This resynchronization can be done in one of two ways.
The normal way of resynchronizing is through the \textit{pull} command,
which fetches the changes in the origin repository, then merges the
branches of the origin repository into the corresponding branch in the
local repository.
The second way of resynchronization breaks the process into two steps,
manually issuing the fetch command and then manually merging or rebasing
branches.
Rebasing is the process of moving a branch from one ancestor to another
commit in the repository.
The process of updating the origin repository with the changes made in
the local repository is known as pushing.
If there are no merge conflicts, the merge can perform a fast-forward
merge, shown in Figure~\ref{fig:fast_forwarded_merge},
which flattens the changes made in the origin repository into the
master branch of the local repository.
Fast-forward merging hides the fact that git would otherwise consider
the two repositories to be separate branches.
Without fast-forward merging, any resynchronization would result in the
addition of a new merge node.
If there is a merge conflict, or the user has specified that the merge
should not fast-forward, a merge commit is created, as shown in
Figure~\ref{fig:merge_node_merge}.

\begin{figure}[htpb]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=0.85\textwidth]{Figures/background/repos/base_repo.png}
    \caption{Example of a basic repository where the local master branch
      is two commits ahead of the origin master branch.}
  \end{subfigure}

  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{Figures/background/repos/fast_forward.png}
    \caption{The fast-forward merge moves the origin branch pointer to
      the current master}
    \label{fig:fast_forwarded_merge}
  \end{subfigure}

  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{Figures/background/repos/merge_commit.png}
    \caption{A merge node is created when fast-forwarding is not
      enabled}
    \label{fig:merge_node_merge}
  \end{subfigure}
  \caption{The distinction between fast forward and non fast forwarding
  merges is shown}
  \label{fig:merge_styles}
\end{figure}

Git is an implementation of a distributed version control system.
Distributed version control gives developers more flexibility with their
local repository and requires the developer to synchronize their local
copy of the repository with the public master repository less often
than with centralized version control.
The public master repository can be thought of as being the equivalent
of the central repository in a centralized system.
Instead of it being enforced by the version control system,
it is a socially agreed upon location where the official version of the
code exists.
Unlike with the centralized version control though,
there is no requirement for the developer to ever push their changes
back to the public repository;
the local repository is completely standalone.
Because the local repository is separate, the developer has more
flexibility to alter the structure of the repository before pushing
the results back into the master repository.

It is often desirable to have the features of version control available
before a feature is ready to be made public, specifically in the case
where many possible implementations may exist.
It is also desirable to have the commits in the master repository be
atomic, a given commit will not leave the project in an inconsistent
state.
The developer can combine, split, and edit, the intermediate commits
before pushing their changes into the central repository.
With centralized version control, all commits should leave the software
project in a consistent state.

With the additional flexibility, the structure of large and active
repositories is more complex than the repositories that are in
centralized version control. This poses a problem for maintainer who
must understand how a commit is integrated into the master branch of a
project and the other commits that are integrated with that commit.
Maintainers must sift through thousands of commits to determine which
changes being made to the current version of the software pertain to
the area of the software that they are maintaining.
Specifically, maintainers must be able to answer two questions;

\begin{textbox}
\begin{itemize}
  \item How is a commit integrated into another branch?
  \item What other commits are integrated with the commit?
\end{itemize}
\end{textbox}

The remainder of this chapters includes related work, a description of
git, the directed acyclic graph used internally by git, and information
about the Linux kernel repository.

\section{Related Work}\label{sec:related_work}

A Version Control System (VCS) tracks the development of a software project,
recording each change as it happens. By tracking the changes, the VCS
contains an entire story of the software, rich with information about
who the authors are, what files are being modified, what where changes
are being made. This makes the VCS vital in providing information about
how a software project is being developed and how the software is
structured. In order to use the information stored in the VCS, users
must be able to gain a clear understanding and summarization of the
changes being made, and how they interact with the rest of the source
code. While there has been extensive research on visualizing software
repositories, previous work does not focus on how commits and merges are
structures in the repository graph, and in extension, how commits are
integrated into a repository. The literature on repository visualization
and summarization can be broken down into three academic subcategories;
communication\cite{Cubranic2005,Begel2010}, aspect-oriented
visualization\cite{Ambros2005,Burch2005,Ambros2009}, and organic
visualizations\cite{ogawa09,Caudwell2010}. A fourth industrial category
exists, including tools like GitKraken and SourceTree. The goal of the
industrial tools is not to extract or synthesize new information from
the repository, but to act as a user-friendly client on top of what git
already provides.

\evantodo{Add links to GitKraken and SourceTree}

Many tools focus on addressing the issue of communication between
developers in inter-team collaborative work. Hipikat\cite{Cubranic2005}
investigated communication between developers, focusing on assisting
with the integration of new developers into a project though
communication, providing the new developer with searchable artifacts of
the changes being made, and where to find them. The artifacts may
include files or bug information, shown in Figure~\ref{fig:hipikat}.
Codebook\cite{Begel2010} also focused on communication, but where
Hipikat focused on assisting new developers find artifacts, Codebook
assists developers with finding who was responsible for creating the
artifact. Codebook used a data-mining technique to determine the
developer of a piece of code, the program manager who wrote the
specification for the code, and the program managers and developers on
the team who were working together. A screenshot of Hoozizat, an
implementation of codebook, is shown in Figure~\ref{fig:codebook}.
Hoozizat and Hipikat use the version control as the archive of artifacts
that are being queried. Neither tool is designed with the goal of
providing information on the topological structure of a source code
repository, nor are these tools designed for visualization purposes, but
they do draw information from the contents of the version control
system.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.9\linewidth]{Figures/introduction/hipikat_bug.png}
  \includegraphics[width=0.9\linewidth]{Figures/introduction/hipikat.png}
  \caption{View of Hipikat, listing bugs that are similar to the one
  being viewed}
  \label{fig:hipikat}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/codebook.png}
  \caption{A screenshot of the search results on Hoozizat, an
    implementation of codebook.}
  \label{fig:codebook}
\end{figure}

Most visualization systems provide information about a certain aspect of
the contents in the repository. The goal being Fractal
Figures\cite{Ambros2005} is to show the division of work between
contributors. The project is represented as a square. The square is then
subdivided based on the proportion that a given contributor contributed
to the project, shown in Figure~\ref{fig:fractal_figures}. The
visualization makes it easy to see where work is evenly divided versus
the projects where a single contributor is doing most of the work.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/fractal_figures.png}
  \caption{Construction of Fractal Figures}
  \label{fig:fractal_figures}
\end{figure}

EPOSee\cite{Burch2005} and Evolution Radar\cite{Ambros2009} use the
information from the version control to determine which files are edited
together. The tools from these papers are designed to help a user
identify the degree to which two files are coupled. Two files are
edited and committed together frequently are said to be more tightly
coupled. This makes it possible to determine when two classes are
semantically related. The evolution radar shown in
Figure~\ref{fig:evolution_radar} places points on a circle based on the
name and coupled they are. The files are arranged around the circle
based on the file name, including the full file path. This has the
effect of grouping files that are from the same directory. The distance
from the center of the circle is dependent on how tightly coupled the
file is to the file be analyzed. A more tightly-coupled file will be
positioned more closely to the center of the circle.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/evo_radar.png}
  \caption{Evolution Radar visualization}
  \label{fig:evolution_radar}
\end{figure}

Hoozizat, Hipikat, Fractal Figures, EPOSee, and Evolution Radar all
extract data from CVS repositories. Our goal is to provide information
about git repositories. Fewer tools are available for generating
visualizations and summaries of git repositories, potentially due to the
DAG model used as the internal structure of git repositories.

\evantodo{Look at this one}
Organic visualizations show patterns in cooperation and communication
that arise within a software project organically. Heller et
al.\cite{Heller2011} plots communication on a map. This visualization
shows communication and cooperation patterns that arise, and how they
cross country boundaries, within a software project. The visualizations
proposed in Gource\cite{Caudwell2010}, shown in
Figure~\ref{fig:gource_view}, shows which files contributors are working
on. Using this, it is possible to draw conclusion about which parts of a
project a given contributor is working on and the group of contributors
working on a given area. Gource uses a graph metaphor structure to
represent the file structure of a repository. Files in the same
directory cluster together to form a node. Edges between the directory
clusters represent which directory contains another, although there is
no way to determine the direction of the relationship. User avatars move
around the graph emitting different beams of colored light depending on
the change being made to the file. Greed indicates the creation of a new
file, yellow indicates a modification, and red indicates the deletion of
a file. The visualization is animated to show how a project grows over
time. Codeswarm\cite{ogawa09}, shown in Figure~\ref{fig:codeswarm}, is
similar to Gource, using an organic timelapse approach to visualizing
the events in the repository. Unlike Gource, which constructs a graph
from the directory structure of project, Codeswarm does not have a graph
structure; developers are the center of the visualizations. When a
developer makes a change to a file, the file lights up and flies toward
the developer. As a developer makes more changes, the files that the
developer is modifying will form a ring around the developer. If
multiple developers are modifying a file, the developer nodes are drawn
together.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{./Figures/introduction/gource-linux.jpg}
  \caption{View of Gource file graph with users operating on a
    repository}
  \label{fig:gource_view}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/codeswarm.png}
  \caption{View of the Postgresql repository in Codeswarm}
  \label{fig:codeswarm}
\end{figure}

There are many non-academic tools that are designed as an interface to
git. While not all of these programs provide visualizations, those that
do use a visual metaphor of the DAG to show topological information
about the commits in the repository. While they ultimately show the same
information, the topology of the repository, the organization of that
information is different.

GitKraken, shown in Figure~\ref{fig:gitkraken_main},  is a popular
commercially written git interface that aims to be efficient, elegant,
and reliable, according to it's official website. On visual inspection,
it appears to satisfy these goals. Overall, the interface is clean, most
actions that are possible with the git command line are available in the
graphical interface. Overall, the tool is effective and garners online
approval from users. The graph itself, shown in the center of the main
view provides users with the same information as the graph visualization
in gitk and the git command line, though it may be visually more
appealing.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/gitkraken_main.png}
  \caption{Screenshot of the main view in GitKraken}
  \label{fig:gitkraken_main}
\end{figure}

GitLab and GitHub are both online repository hosts, with
visualization and summarization provided as well. While the GitLab
visualization does not appear to provide any additional information, the
visualization provided by GitHub takes advantage of additional internal
knowledge to display information about forks. Through this
visualization, GitHub displays the branch history of the repository
network, including the branches of the main repository and forks from
that. Giteye and most of the other visualizations are relatively
conventional, simply cleaning up the interface of Gitk, the visualizer
that is shipped with git. With the exception of Gitk, no GUI visualizers
are able to produce a visualization for the Linux repository, due to its
size: the GitHub visualizer displays an error message, stating that
there are too may forks to display; the GitKraken interface will freeze
and eventually crash while trying to load the repository, while Giteye
and the other visualizers will consume all of the system memory before
they are able to produce a visualization. The Gitk interface is the
least polished, but is able to produce a visualization of the
repository.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/giteye_graph.jpg}
  \caption{Screenshot of Giteye DAG view of a repository}
  \label{fig:giteye_screenshot}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/github_dag.png}
  \caption{GitHub online network view of a repository}
  \label{fig:github_dag_screenshot}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/introduction/gitlab_graph.jpg}
  \caption{GitLab online graph view}
  \label{fig:gitlab_dag_screenshot}
\end{figure}

\section{Git}
\label{sec:git}

% Commits;
Commits are the most basic unit of change in the git repository.
Commits are how the changes and metadata are stored.
Commits in git are immutable; they cannot be changed once they are
created. Instead, modifying a commit will result
in a new commit with a different commit hash.
Because the commits that follow have references to the updated commit,
those commits are copied and receive a new commit hash as well.
Commits store the commit hash, commit date,
committer, author, and authorship date, the patch, and an ordered list
of parents. The metadata is shown in Figure~\ref{fig:commit_metadata}
for a commit and merge within the repository for this \paper{}.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/background/commit_metadata.png}
  \caption{Screenshot of commit metadate for a commit and merge in the
    repository for this \paper{}.}
  \label{fig:commit_metadata}
\end{figure}

Git allows commits to be made on the behalf of another person, either
via email, or simply because the author of the commit doesn't have the
ability to write to the repository.
When someone else makes the commit, the committer and author will not
match. The patch contains the changes being made, including the
filenames, the line numbers, and the actual change, as shown in
Figure~\ref{fig:commit_patch}.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/background/commit_patch.png}
  \caption{Example of a commit patch from the Linux kernel repository
    from commit \textit{c03567a8e8d5}.}
  \label{fig:commit_patch}
\end{figure}

The parents of a commit are the next commits toward the initial commit.
The first parent in the list is the commit that is on the same branch
as the commit that is being created, i.e, the branch that the other
branches are being merged into.
The remaining commits are the branches being merged, in the order that
they are specified in the merge.
A non-merging commit will only have one parent.
To clarify the difference, non-merging commits are referred to as
commits, merging commits as merges.
In the scope of this thesis, repository event or event is used to refer
to both commits and merges.
The patch are set of changes being made to the files of the repository.

% Integration;
Integration is the process by which the changes in a commit are added to
the master repository.
A small change with few dependencies are easier to integrate than
changes.
It is possible to merge these changes into the master repository
without additional commits making changes.
The changes are directly merged into the master repository.
Many times, these changes are small, localized, bug fixes, or modifications to
documentation, which can be integrated with the rest of the project
without making changes beyond the scope of the bug or documentation.
An example of this from the Linux repository is shown in
Figure~\ref{fig:single_commit_merge}.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/background/single_commit.png}
  \caption{Example of a merge that only integrates a single commit}
  \label{fig:single_commit_merge}
\end{figure}


Adding additional functionality to a project may require additional
support from other components of the project.
Non-localized changes may be necessary to provide the additional
information needed for the new function.
Commits can be logically grouped based on the submodule that grouped
based on what part of the project they are modifying.
In the Linux kernel, it is customary to have commits related to
networking in a single merge.
This merge has sub-merges containing wireless networking, Bluetooth,
and Ethernet, among the other implementations of networking.
In this form, the merges act in a similar manner to subdirectories in a
file system, where each directory contains files that work together.

Projects may also be shared between multiple organizations.
The organizations will likely have their own internal master
repositories that they work with before pushing the full set of
changes upstream to the public master repository.
In git, it is possible to merge repositories since they are treated in
the same way as local branches.

In order to integrate the changes, the commits must be merged into the
master branch of the repository.
Commits may be merged directly into the master branch, or may be merged
into multiple branches before finally reaching the master branch.
To understand how a commit is integrated, it is necessary to know which
merges a commit passes through to reach the master branch, and which
commits are merged with it.
Merging commits is the process of integrating them.

Merges are a type of commit; it is possible to make additional
changes while merging.

When two commits from different branches make changes to the same file,
a conflict occurs.
Git is unable to determine which changes are correct, so it flags them
as a merge conflict, which stops the merging process.
The person making the merge decides which change should be kept,
and which should be removed.
The resolution of merge conflicts is stored as the patch of merge
conflicts.
The Linux repository has no merge conflicts.
This is attained through a different workflow.
When a developer wants to merge their changes, they must first rebase
their branch onto the most up-to-date commit of the repository.
When this happens, if there are conflicts, git will require
the developer to make the fixes.
The main difference being that the developer fixes conflicts,
not the person performing the merge.
The idea behind this is that the developer likely has a better
understanding of which change is the correct, or how to integrate both
changes.

\section{Directed Acyclic Graph}
\label{sec:directed_acyclic_graph}

To allow for the flexibility needed for a distributed version control
system, git uses a \define{directed acyclic graph}{DAG} as the central
repository model.
The repository events make up the nodes in the graph, and the
child-parent relationship represents the edges.
Commits will have a single parent, which is the repository event that
is at the head of the current branch at the time that the commit
is created.
Merge nodes have an ordered list of
parents\footnote{It is possible for a merge to have many parents, commit
  2cde51fbd0f310c8a2c5f977e665c0ac3945b46d has 66 parents},
each parent is the head of each branch being merged.
The first parent is the head of the current branch, and the other
parents are the heads for the other branches being merged, in the order
that they are specified in the merge command.
Every repository will have at least one initial commit, which
will have no parents, but it is possible for repositories to have
multiple initial commits.
Furthermore, it is possible for the graph of a repository to be
disconnected; these branches are known as orphan branches.

The model itself is quite simple but flexible. While the flexibility of
a git repository is usually a strength, there are situations where it
makes reasoning about the contents more difficult. The idea of a main
master branch is useful for people who are working with the repository.
Unlike many centralized repositories, which have a concept of a main
branch, usually referred to as the trunk, git has no functional
requirement for the existence of a main branch. Instead, the main branch
is maintained by the discipline of the people committing code to the
repository. As a convention in git, the first parent of a node is on the
same branch as that node. A \foxtrot\footnote{See
  \url{http://bit-booster.blogspot.ca/2016/02/no-foxtrots-allowed.html}
  for a full description of the issue.} merge occurs when the parent
list is re-ordered, thus confounding the branch relationships
(depicted in Figure~\ref{fig:foxtrot_steps}).

\begin{figure}[htpb]
  \centering
  \begin{tabular}{ccc}
    \includegraphics[width=114px]{Figures/background/foxtrot_initial.png} &
    \includegraphics[width=145px]{Figures/background/foxtrot_good.png} &
    \includegraphics[width=145px]{Figures/background/foxtrot_bad.png} \\
    Initial Repository & No Foxtrot & Foxtrot
  \end{tabular}
  \caption{Depiction of a foxtrot merge, where the master branch is
    confounded by \emph{branch2}}
  \label{fig:foxtrot_steps}
\end{figure}

The nodes in the DAG are immutable; once a commit or merge is created,
it cannot be changed. Git allows operations to alter the events and
re-order them, but this will create a new event with a new commit hash.
This property makes it impossible for nodes to store information about
the children, and in extension, how the commit is being merged as this
information is not available when the commit is created. Git provides
the command \verb|git log --children|, which traverses the DAG and
inverts the edges. Combining this with the graph output partially solves
the problem of understanding how a commit is merged into the master
branch as it shows how a commit was merged; however, the resulting graph
is still complicated.

Most repositories are simple enough that it is possible to identify how
commits are integrated using the visualizations of the DAG that are
available with the current tools. Difficulties arise in larger
repositories. The master branch can be counfounded with \foxtrot{}
merges, making it difficult to identify. Sheer number of commits being
added to various branches at a given time can make it difficult to
understand which branch a commit is being added to.

\section{Linux}\label{sec:linux}

This \paper{} studies the repository of the Linux kernel. The repository
itself is complex, contain tens of thousands of commits per year and
thousands of merges. Older versions of the kernel are used in a wide
variety of situations including various Linux desktop distributions,
internet of things device firmware, web servers,
spacecrafts\footnote{Linux is used heavily at SpaceX
  \url{https://lwn.net/Articles/540368/}}, and in mobile devices as the
base of the Android platform. These kernels are sometimes modified forks
of the official Linux kernel, made to be more suitable for the specific
needs of the application. Due to these application-specific
modifications, it is not feasible to update to the latest version of the
kernel. While it may not be feasible to update, the changes being made
to the official version are necessary as they fix bus, patch security
issues, and improve performance. Due to the sometimes critical nature of
the patches being merged into the current version of the kernel, it is
necessary for maintainers working on an application-specific fork of the
kernel to sift through the commits coming into the official version,
looking for changes that may impact the kernel that they are
maintaining. This section presents some statistics about the contents of
the kernel repository.

Linux is open source, using git to track and manage the source code in
the kernel. A mirror of the repository is available on
GitHub\footnote{\url{https://github.com/torvalds/linux}}, which makes
data collection relatively straightforward. Described in this section is
the dataset that was collected, further investigating the number of
authors, commits, and merges.

The data extracted from the repository involves all merges into the
master branch between April 18, 2005 and August 14, 2014. This
corresponds to the merges added to the kernel between versions 2.6.11
and Linux 3.16. The commits collected from the repository include
commits authored between September 17, 2001 and December 6, 2014. There
are 4 commits in the dataset that are beyond this range due to the date
being incorrectly set on that developer's machine. There is one
incorrect date that is dated January 1, 1970, authored by Ursula Braun,
and three commits dated after 2014. These commits are dated April 5,
2019, October 14 2030, and April 25 2037, authored by Len Brown, Yanmin
Zhang, and Daniel Vetter, respectively. Commits are not necessarily
merged immediately, all commits were added between April 15, 2005 and
October 14, 2014. The average difference between when a commit was
created and when it was committed is 16 days and 10 hours; 25\% of the
commits were committed within 2 hours of being authored, 50\% committed
within 2 days and 8 hours, 75\% within 15 days, and all commits were
merged within 9.5 years of being authored. This breakdown of the kernel
data focuses on the commits integrated into kernel versions Linux 3.1 to
Linux 3.16, translating to the merges between July 21, 2011 and August
3, 2014.

As expected, the Linux kernel is highly collaborative and is very
active. Between 1000 and 1500 authors have contributions accepted into
the official kernel per release (shown in
Figure~\ref{fig:linux_authors_per_release}). These authors contribute
between 8000 and 14000 commits per release
(Figure~\ref{fig:linux_commits_per_release}). Between 275 and 400 merges
integrate the commits into the master branch of the kernel per release
(Figure~\ref{fig:linux_commits_per_release}). The Linux kernel
repository is a prime example of a successful open source project,
exemplifying the collaborative nature of modern software development.
The sheer number of commits being contributed make the task of filtering
the important or relevant commits impractical.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/background/linux_authors_per_release.pdf}
  \caption{Unique authors with contributions to each kernel version}
  \label{fig:linux_authors_per_release}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth, page=1]{Figures/background/linux_commits_per_release.pdf}
  \caption{Commits per release from Linux 3.1 to Linux 3.16}
  \label{fig:linux_commits_per_release}
\end{figure}

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth, page=2]{Figures/background/linux_commits_per_release.pdf}
  \caption{Merges per release from Linux 3.1 to Linux 3.16}
  \label{fig:linux_merges_per_release}
\end{figure}

While the number of integrating merges into the master branch appears to
be decreasing slightly per release, the number of commits per release is
increasing. The average (mean) number of commits per merge per release
has increased from slightly over 20 commits per merge in Linux 3.1 up to
50 commits per merge in Linux 3.16
(Figure~\ref{fig:linux_commits_per_merge_per_release}).

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth, page=3]{Figures/background/linux_commits_per_release.pdf}
  \caption{Commits per merge into each release of Linux from 3.1 to 3.16
    \evan{Should probably go in the appendix}}
  \label{fig:linux_commits_per_merge_per_release}
\end{figure}

Grouping commits by the merge that integrates it into the master branch
shows a different view of the kernel. The individual merges contain
relatively few commits, 25\% of the merges merge only a single commit,
and 50\% of the merges merge at most 7 events
(Figure~\ref{fig:linux_merge_distribution_per_release}).

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.8\linewidth]{Figures/background/linux_merge_distribution_per_release.pdf}
  \caption{Distribution of Merge Sizes per Release Between Linux 3.1 and
  3.16}
  \label{fig:linux_merge_distribution_per_release}
\end{figure}

Initially, the repository looks very large and unmanageable. Grouping
the commits using the merge into the master branch looks like a
promising means of simplifying the content. Most of the merges are only
merging 7 events, which is nearly trivial to visualize.
